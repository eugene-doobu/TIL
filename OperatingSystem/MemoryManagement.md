# 메모리 관리 전략

프로세스는 독립된 메모리 공간을 갖고 있고, 운영체제 혹은 다른 프로세스의 메모리 공간에 접근할 수 없는 제약이 걸려 있다. 오로지 운영체제 만이 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 제약을 받지 않는다.

Swapping: 메모리의 관리를 위해 사용되는 기법. 표준 Swapping 방식으로는 round-robin과 같은 스케줄링의 다중 프로그래밍 환경에서 CPU 할당 시간이 끝난 프로세스의 메모리를 보조 기억장치(하드디스크)로 내보내고 다른 프로세스의 메모리를 불러 들일 수 있다.

swap에는 큰 디스크 전송시간이 필요하기 때문에 현재에는 메모리 공간이 부족할때 Swapping이 시작된다.

## 단편화(Fragmentation)

프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면, 프로세스들이 차지하는 메모리 틈 사이에 사용 하지 못할 만큼의 작은 자유공간들이 늘어나게 되는데, 이것이 단편화이다.

### 외부 단편화

메모리 공간 중 사용하지 못하게 되는 일부분. 물리 메모리에서 사이사이 남는 공간들을 모두 합치면 충분한 공간이 되는 부분들이 분산되어 있을 때 발생

### 내부 단편화

프로세스가 사용하는 메모리 공간에 포함된 남는 부분

### 압축

외부 단편화를 해소하기 위해 프로세스가 사용하는 공간들을 한쪽으로 몰아 자유공간을 확보하는 방법론. 하지만 작업효율지 좋지 못함

## 페이징

하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법. 외부 단편화와 압축 작업을 해소하기 위해 생긴 방법론으로, 물리 메모리는 Frame이라는 고정 크기로 분리되어 있고, 논리 메모리(프로세스가 점유하는)는 페이지라 불리는 고정 크기의 블록으로 분리.

페이징 기법을 사용함으로써 논리 메모리는 물리 메모리에 저장될 때, 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절히 배치됨으로 외부 단편화를 해결할 수 있는 큰 장점이 있다.

하나의 프로세스가 사용하는 공간은 여러개의 페이지로 나뉘어서 관리되고, 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 mapping되어 저장된다고 볼 수 있다.

단점: 내부 단편화 문제의 비중이 늘어나게 된다. 프로세스의 요구 메모리를 프레임 단위로 분할해야 하므로, 매우 작은 메모리 할당을 위해 한개의 페이지를 추가해야 되는 경우가 생길 수 있다.

## 세그멘테이션

페이징에서처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적 단위인 세그먼트로 분할하여 사용자가 두 개의 주소로 지정(세그먼트 + 변위). 세그먼트 테이블에는 각 세그먼트의 기준과 한계(길이)를 저장

단점: 서로 다른 크기의 세그멘트들이 메모리에 적재되고 제거되는 일이 반복되다 보면 자유 공간들이 많은 수의 조각들로 나누어져 외부 단편화가 심해질 수 있다.

## 메모리 관리 기법별 비교

고정 크기: 페이징(Paging)

가변 크기: 세그멘테이션(Segmentation)

### 페이징

각 프로세스는 프레임들과 같은 길이를 가진 균등 페이지로 나뉨

외부 단편화 X

소량의 내부 단편화 존재

### 세그멘테이션

각 프로세스는 여러 세그먼트들로 나뉨

내부 단편화 X, 메모리 사용 효율 개선, 동적 분할을 위한 오버헤드 감소

외부 단편화 존재

### 가상 메모리 페이징

단순 페이징과 비교해 프로세스 페이지 전부를 로드시킬 필요 X

필요한 페이지가 있으면 나중에 자동으로 불러들어짐

외부 단편화 X

복잡한 메모리 관리로 오버헤드 발생

### 가상 메모리 세그멘테이션

필요하지 않은 세그멘트들은 로드되지 않음

필요한 세그멘트 있을 때 나중에 자동으로 불러들어짐

내부 단편화 X

복잡한 메모리 관리로 오버헤드 발생
