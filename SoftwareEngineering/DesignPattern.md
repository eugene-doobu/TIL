# 디자인패턴

## 명령(command) 패턴

명령 패턴은 메서드 호출을 실체화한 것. 이것은 함수 호출을 객체로 감쌌다는 의미이다. 프로그래밍 언어 배경에 따라 '콜백', '일급 함수', '함수 포인터', '클로저', '부분 적용 함수'라고 불린다.

```C#
Action space;
Action w;
action a;
action s;
action d;

void ProcessInput(KeyInput input)
{
    if(input == KeyInput.SPACE) space.invoke();
    if(input == KeyInput.W    )     w.invoke();
    if(input == KeyInput.A    )     a.invoke();
    if(input == KeyInput.S    )     s.invoke();
    if(input == KeyInput.D    )     d.invoke();
}
```

Command 객체를 선택하는 AI와 이를 실행하는 액터를 디커플링함으로써 코드가 훨씬 유연해진다. 이를 응용하여 실행취소와 재실행기능을 만들기도 좋다.

## 경량 패턴

객체를 마구 늘리지 않으면서도 객체지향의 장점을 취할 수 있다. 열거형을 선택해 수많은 다중 선택문을 만들 생각이라면, 경량 패턴을 먼저 고려해보자.

수천 그루의 나무를 렌더링 할 때, 수천 개의 나무를 수천 폴리개의 형태로 표현하여 GPU에 전달하는 것은 부하가 너무 크다. GPU로 보내는 데이터 양을 최소화하기 위해서는 공유 데이터인 TreeModel을 딱 한번만 보내고 그 후에 나무마다 값이 다른 위치, 색, 크기를 전달하여 처리하여야 한다. instanced rendering을 활용하여 단 한번의 drawcall로 수천 그루의 나무를 처리할 수 있다.

이와 같이 모든 객체의 데이터 값이 같아서 공유할 수 있는 데이터를 모아(GoF에서의 고유 상태) 반복되는 데이터를 한번에 처리한다. 그 다음 인스턴스별로 값이 다른(외부 상태)데이터를 적용하여 연산을 경량화한다.

## 관찰자 패턴

객체 사이의 일 대 다 의존 관계를 정의해두어, 어떤 객체의 상태가 변할 때 그 객체의 의존성을 가진 다른 객체들이 그 변화를 통지 받고 자동으로 업데이트될 수 있게 만듭니다.(GoF의 디자인 패턴)

관찰자 패턴을 사용하면 어떤 코드에서 흥미로운 일이 생겼을 때 누가 받든 상관없이 알림을 보낼 수 있다. 어떤 기능에 영향을 받을 엑터들을 동적으로 자유롭게 등록하고 제거할 수 있다.

## 프로토타입 패턴

원형이 되는 인스턴스를 사용하여 생성할 객체의 종류를 명시하고, 이렇게 만든 견본을 복사하여 새로운 객체를 생성합니다.(Gof의 디자인 패턴)



## Reference

게임프로그래밍패턴(한빛미디어)