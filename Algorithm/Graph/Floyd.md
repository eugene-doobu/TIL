# 플로이드-워셜(Floyd-Warshall) 알고리즘

모든 최단 경로를 구하는 알고리즘

모든 정점 쌍 사이의 거리를 구해주는 알고리즘

간선의 값이 음수여도 잘 동작하지만, 음수인 사이클이 있으면 문제가 생김

최단 거리 테이블을 갱신시켜 나가며 최단거리를 구해나가는데, 이때 어떤 정점을 거쳐가면 더 적은 거리를 갈까 비교

정점이 V개라고 할 때, 총 V단계에 거쳐 갱신이 이루어지고, 갱신때마다 V^2의 모든 D[s][t]값을 D[s][k] + D[k][t]와 비교하기 때문에(k는 현재 추가로 거쳐갈 정점) O(V^3)

## 구현
```cpp
// 대각선은 자기 자신으로의 이동을 뜻하므로 0
for (int i = 1; i <= n; i++) d[i][i] = 0;
for (int k = 1; k <= n; k++)
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
```

구현 주의사항

- INF값 덧셈시 overflow를 고려할것!(가능하다면 0x3f3f3f3f같은 값을 INF로 사용)
- 플로이드는 그래프를 인접 행렬 형식으로 나타낸다
- 자기 자신으로 가는 경우(대각선))은 0으로 설정
- 3중 for문을 구성할 때 위 예제처럼 거쳐가는 정점(k)을 가장 밖에 위치시켜야 한다
- 정점 1000개 까지는 플로이드 알고리즘으로 풀어볼만 하다
- 일반적으로 연산보다 대입이 느리기 때문에, 매번 대입이 일어나게 하는것보다 if문을 활용해서 필요한 경우에만 대입을 일어나게 하는게 유리하다(상수 시간 최적화) 

## 경로복원

- nxt테이블을 구현하여, D[s][t]값이 갱신될 때 마다 해당 테이블에 정점 기록
- 경로복원시 이 테이블을 참조하여 앞으로 전진

## 참조

[바킹독 플로이드](https://www.youtube.com/watch?v=dDDy2bEZRA8)

바킹독 강추!!